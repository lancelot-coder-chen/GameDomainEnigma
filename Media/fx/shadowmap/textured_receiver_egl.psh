#version 300 es
//semantic DiffuseTexture DiffuseMap
//semantic ShadowTexture ShadowMap
//semantic Ambient AmbientLight
//semantic SunColor SunLightColor
//semantic SunDir SunLightDirection
//semantic LightViewProj LightViewProj
//semantic ShadowMapSliceDimension ShadowMapSliceDimension
precision highp float;
//sampler_state samLinear DiffuseTexture
//sampler_state samShadow ShadowTexture
uniform sampler2D ShadowTexture;
uniform sampler2D DiffuseTexture;
uniform vec4 Ambient;
uniform vec4 SunColor;
uniform vec4 SunDir;
uniform mat4 LightViewProj;
uniform vec4 ShadowMapSliceDimension;
#define ShadowMapSliceWidth 	ShadowMapSliceDimension.x
#define ShadowMapSliceHeight 	ShadowMapSliceDimension.y
#define ShadowDepthBias			ShadowMapSliceDimension.z
#define ShadowMapDensity		ShadowMapSliceDimension.w
in vec3 vNor;
in vec2 vTexCo;
in vec4 vWorldPos;
out vec4 outColor;

vec4 CommonDiffuseLighting( in vec4 world_pos, in vec3 world_nor, in float light_amount )
{
	vec4 diffuse = Ambient;
	vec3 sun_dir = vec3(SunDir.x, SunDir.y, SunDir.z);
	diffuse = diffuse + ( ( SunColor * clamp ( dot ( world_nor, sun_dir ), 0.0f, 1.0f ) ) * light_amount * ( vec4(1.0, 1.0, 1.0, 1.0) - Ambient ) );
	return diffuse;
}
float CalcShadowDecay(vec4 light_proj)
{
    vec2 ShadowTexC = 0.5 * light_proj.xy / light_proj.w + vec2( 0.5, 0.5 );
    //ShadowTexC.y = 1.0f - ShadowTexC.y;
	//vec4 depth_vec = texture(ShadowTexture, ShadowTexC);
    float depth_value = texture(ShadowTexture, ShadowTexC).r;
	float lightAmount = 1.0f;
	if (depth_value + 0.000005f < light_proj.z / light_proj.w)
	{
		lightAmount = ShadowMapDensity;
	}
    return lightAmount;
}

void main() {
    outColor = texture(DiffuseTexture, vTexCo);
    vec4 diffuse = CommonDiffuseLighting(vWorldPos, vNor, 1.0f);
	vec4 lightProj = vWorldPos * LightViewProj;
    if ( ( lightProj.x < -1.0f ) || ( lightProj.y < -1.0f ) || ( lightProj.x > 1.0f ) || (lightProj.y > 1.0f ) )
	{
		outColor = outColor * diffuse;
		return;
	}

    outColor = outColor * diffuse * CalcShadowDecay(lightProj);
}
